# 연관관계와 프록시

## 연관관계 매핑
* 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
* `테이블`은 `외래키`로 조인을 사용하여 `연관된 테이블`을 찾는다.
* `객체`는 `참조`를 사용해서 `연관된 객체`를 찾는다.
	* 객체를 테이블에 맞추어 모델링? -> 참조가 아닌 외래키 식별자를 다루어 해당 식별자로 객체를 다시 조회하게 된다. -> 객체지향과 맞지 않음
* 객체지향 모델링 -> 테이블의 외래키를 객체의 참조와 매핑. 이를 `연관관계`라고 한다.
* `참조`를 통해 객체 그래프 탐색 가능

### 연관관계 종류
- 단방향 연관관계
	- 한 방향으로만 객체 그래프를 탐색할 수 있는 연관관계로 한쪽 객체에만 참조를 둔다.
- 양방향 연관관계
	- 양방향으로 객체 그래프 탐색 가능. 양쪽 객체 모두 참조를 둔다.

### 외래키는 어디서 관리하나
* `테이블`은 **외래키 하나로 두 테이블의 연관관계를 관리**
* `객체`는 **외래키를 참조로 사용**
* 양방향 연관관계는 양쪽 다 참조가 있기 때문에 `연관관계의 주인`을 설정하여 기준을 잡아주도록 한다.

### 연관관계의 주인
* 객체의 양방향 관계 = 서로 다른 단방향 관계 2개
* 2개의 단방향 중 하나를 연관관계의 주인으로 지정하여 외래키를 관리하도록 한다.
* 다음 규칙을 갖는다.
	* 객체의 두 관계 중 하나를 연관관계의 주인으로 지정한다.
	* 연관관계의 주인만이 외래키를 관리한다. (등록, 수정)
	* 주인이 아닌쪽은 읽기만 가능하다.
	* 주인이 아니면 `mappedBy` 속성을 사용
	* 외래키가 있는 곳을 주인으로 한다 (1:* 에서 *쪽에 외래키)

### 양방향 매핑시 주의할 점
* **순수 객체 상태를 고려**하여 **항상** 양쪽에 값을 설정하자.
* **연관관계 편의 메소드**를 생성하여 실수를 줄이도록 하자.
```java
// Member의 Team을 설정함과 동시에 team의 members(Member List)에 해당 Member를 추가 -> 각각 호출하는 것 보다 실수할 확률 감소
public void setTeam(Team team) {
	this.team = team;
	team.getMembers().add(this);
}
```
* 양방향 매핑시 **무한 루프를 조심**

---
## 프록시
* 데이터 조회시 연관된 객체 조회를 미룬다 (DB 조회를 미루는 가짜 엔티티 객체)
- 프록시 객체의 특징
	* 프록시 객체는 실제 객체의 참조를 보관함 (실제 객체를 상속받음)
	* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드를 호출한다.
	* 프록시 객체는 처음 사용할 때 한 번만 초기화됨.
	* 프록시 객체가 초기화시, 실제 엔티티로 바뀌지 않음.
	* 원본 엔티티를 상속받았기 때문에 타입 체크시 `instance of` 사용

### 프록시 설정
* `@ManyToOne`, `@OneToMany` 등 다중성 설정시, `fetch` 속성 지정
* **지연로딩**
	* `fetch=FetchType.LAZY`
	* 해당 속성이 지정된 참조 객체는 프록시로 조회되어 프록시가 사용될 때 까지 실제 엔티티 조회를 미룬다.
* **즉시로딩**
	* `fetch=FetchType.EAGER`
	* 객체 조회시 프록시로 가져오는 것이 아니라 실제 엔티티를 같이 가져온다.

### 가능하면 지연로딩만 쓰자
* 즉시로딩을 적용하면 예상하지 못한 SQL이 발생한다.
* 즉시로딩은 JPQL에서 N + 1 문제를 발생시킨다.
* ToOne은 기본이 즉시로딩이다. LAZY로 설정해주자.
* ToMany는 기본이 지연로딩이다.


#JPA/연관관계
#JPA/프록시
---

해당 내용은 김영한님의 강의를 듣고 정리한 내용입니다.
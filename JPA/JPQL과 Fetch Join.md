# JPQL과 Fetch Join
## JPQL
* SQL을 추상화한 객체 지향 쿼리 언어다.
* SQL은 DB 테이블을 대상으로 쿼리한다.
* JPQL은 엔티티 객체를 대상으로 쿼리한다.
* SQL을 추상화했기 때문에 특정 DB SQL에 의존하지 않는다.

### TypeQuery, Query
* TypeQuery : 반환 타입이 명확할 때 사용
* Query : 반환 타입이 명확하지 않을 때 사용

### 프로젝션
* SELECT 절에 조회할 대상을 지정하는 것이다.
* select m from ...
	* 엔티티 프로젝션
* select m.address from ...
	* 임베디드 타입 프로젝션
* select m.username from ...
	* 스칼라 타입 프로젝션

### 페이징 API
* `setFirstResult(int startPosition)`
* `setMaxResults(int maxResult)`

### JOIN - ON
* on 절은
	* 조인 대상을 필터링.
	* 연관관계가 없는 엔티티를 외부 조인하게끔 해준다.

### 경로 표현식
* `.`을 찍어서 **객체 그래프를 탐색**하는 것.
* 상태 필드와 연관 필드가 있다.
* 상태 필드는 단순히 값을 저장하기 위한 필드다.
* 연관 필드는 연관관계를 위한 필드다.
	* 단일 값 연관 필드 - 대상이 엔티티. ToOne
	* 컬렉션 값 연관 필드 - 대상이 컬렉션. ToMany
* 경로 탐색을 통한 묵시적 조인은 항상 내부 조인이 일어난다.
* 가급적이면 명시적 조인을 사용하자.
	* 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어렵다.

- - - -
## fetch join
* JPQL에서 성능 최적화를 위해 제공하는 기능이다.
* 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능이다.
* `join fetch`
* 페치 조인으로 가져오면 지연 로딩이 발생하지 않아서 성능이 최적화 된다.

### distinct
* JQPL에서 distinct는 sql에 distinct를 추가하고, 애플리케이션에서 엔티티 중복을 제거한다.
* 일대다 관계에서 일을 기준으로 조인하여 SQL 검색을 하면 데이터가 뻥튀기 된다. -> 중복된 데이터가 있다.
* JPQL에서 fetch join으로 데이터를 가져올 때, distinct를 사용하면 애플리케이션으로 가져온 data를 엔티티로 넣으면서 같은 식별자를 가진 엔티티를 제거해준다. -> 중복 제거
* fetch join은 객체 그래프를 SQL 한번에 조회하는 개념이다.

### fetch join 한계
* fetch join 대상에는 별칭을 줄 수 없다.
* 둘 이상의 컬렉션은 fetch join 할 수 없다.
* 컬렉션을 fetch join 하면 페이징 API를 사용할 수 없다.
	* SQL 결과는 데이터가 뻥튀기 되버리기 때문이다.
	* 하이버네이트는 경고 로그를 남기고 메모리에서 페이징한다.
	* 메모리 용량이 딸릴(?) 수 있다. 위험하다.

> 여러 테이블을 조인해서 엔티티가 가진 모양이 아니라 전혀 다른 결과를 내야한다면, fetch join 보다는 일반 조인을 사용하고, 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적이다.  

- - - -
## 다형성 쿼리
### TYPE
* 조회 대상을 특정 자식으로 한정한다.

### TREAT
* 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용한다.

- - - -
## 벌크 연산
* executeUpdate()
	* 쿼리 한번으로 여러 테이블 row를 변경한다.
	* 영향받은 엔티티의 수를 반환한다.
	* Update와 Delete를 지원한다.
	* 하이버네이트는 insert도 지원한다.
* 하지만 벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리한다.
* 따라서 벌크 연산 수행 후 영속성 컨텍스트를 초기화 해줘야 한다.



#JPA/JPQL
#JPA/Fetch Join#
#JPA/다형성쿼리
#JPA/Bulk 연산#
- - - -

해당 내용은 김영한님의 강의를 듣고 정리한 내용입니다.
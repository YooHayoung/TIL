# JPA

##  JPA 란?
- Java Persistence API
- 자바 진영의 ORM 기술 표준이다.

<br>

## 그럼 ORM 은?
- Object-relational mapping (객체 관계 매핑)
- 객체는 객체대로 설계하고 RDB는 RDB대로 설계한다.
- ORM 프레임워크가 중간에서 매핑해준다. (JPA)

<br>

## JPA는 표준 명세다.
- JPA는 인터페이스의 모음이다.
- 이를 구현한 3가지 구현체로는 Hibernate, EclipseLink, DataNucleus 있다.

<br>

## JPA는 왜 써야하나?
- SQL 중심적인 개발에서 객체 중심으로 개발할 수 있다.
- 생산성 증가
- 유지보수 Good
- 패러다임 불일치 해결
- 높은 성능
- 데이터 접근 추상화와 벤더 독립성 (?)
- 표준이다.
  
<br>

---

<br>

## JPA 구동 방식
- Persistence 에서 설정 정보 조회
- 이를 기반으로 EntityManagerFactory 생성 <br> EntityManagerFactory는 1개만 생성하여 애플리케이션이 공유한다.
- EntityManagerFactory가 EntityManager 생성. <br> EntityManager는 Factory에서 Session마다 생성하여 사용하고 버린다. 쓰레드마다 공유 X
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행된다.

<br>

---

<br>

## 영속성 컨텍스트
- JPA를 이해하는데 가장 중요한 용어다.
- 엔티티를 영구 저장하는 환경이라는 뜻
- 논리적인 개념
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.
- J2SE 환경에서는 EntityManager와 영속성 컨텍스트가 1:1 임
- J2EE, Spring Framework 같은 Container 환경에서는 EntityManager와 영속성 컨텍스트가 N:1 이다.

<br>

## Entity의 생명주기
- 비영속 <br> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 <br> 영속성 컨텍스트에 관리되는 상태
- 준영속 <br> 영속성 컨텐스트에 저장되었다가 분리된 상태
- 삭제 <br> 삭제된 상태

<br>

## 그럼 영속성 컨텍스트를 통하면 얻는게 뭔데?
- 1차 캐시
  - Entity를 영속화하거나 DB에 저장된 Entity를 불러오면 1차 캐시에 일단 저장한다. 
  - DB에 검색을 할 때, 1차 캐시에서 먼저 확인 후 존재하는 Entity는 Query를 날리지 않고 가져온다.
  - 1차 캐시에 없다면 그 때 DB Server에 Query를 날려서 가져온다.
- 동일성(identity) 보장
  - 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 DB가 아닌 Application 차원에서 제공한다.
  - 1차 캐시에서 가져온 Entity는 동일한 Entity임을 보장 하는 것이다. ( == 비교 true )
- 트랜잭션을 지원하는 쓰기 지연
  - EntityManager.persist(member) <- 영속화 시점에 DB에 SQL을 보내는 것이 아니다.
  - 1차 캐시에 저장하였다가 commit 시점에 SQL을 전송하여 DB에 저장한다.
- Dirty Checking
  - 트랜잭션 내에서 영속 상태의 Entity를 수정한다.
  - 트랜잭션 커밋 시점에 1차 캐시에서 Entity의 스냅샷과 비교한다.
  - 스냅샷과 다르면 update Query를 날린다.
- Lazy Loading

<br>

---

<br>

## Entity Mapping

<br>

### @Entity
- JPA가 관리하는 클래스에 붙인다.
- JPA를 사용하여 테이블과 매핑할 클래스는 @Entity 필수임
- JPA spec상 public or protected 기본 생성자 필요하다.
- final 클래스, enum, interface, inner 클래스 사용 불가
- 저장할 필드에 final 사용 불가

<br>

## 매핑 어노테이션 정리
- @Column <br> 컬럼 매핑
- @Temporal <br> 날짜 타입 매핑 (요즘엔 LocalDateTime을 사용해서 잘 안쓴다)
- @Enumerated
  - enum 타입 매핑
  - value 속성에 ORDINAL이 아닌 STRING을 사용하자.
  - ORDINAL 사용하면 enum 값이 변경될 시에 순서가 변경될 우려가 있다.
- @Lob <br> BLOB, CLOB 매핑
- @Transient <br> 특정 필드를 컬럼에 매핑하지 않는다.

<br>

---

## 연관관계 매핑 
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
- 테이블은 외래키로 조인을 사용하여 연관된 테이블을 찾는다.
- 객체는 참조를 사용해서 연관된 객체를 찾는다.
- 객체를 테이블에 맞추어 모델링하면 참조가 아닌 외래키 식별자를 다루어 해당 식별자로 객체를 다시 조회하게 된다.
- 이건 객체지향스럽지 않다...

<br>

### 그래서 어떻게 해결하는데?
- 객체지향 모델링을 하자.
- 테이블의 외래키를 객체의 참조와 매핑하는 것이다.
- 이를 연관관계라고 한다.
- 참조를 통해 객체 그래프 탐색 가능

<br>

### 단방향 연관관계
- 한 방향으로만 객체 그래프 탐색할 수 있는 연관관계이다.
- 한쪽 객체에 참조를 두고 다른쪽은 두지 않는다.

<br>

### 양방향 연관관계
- 양방향으로 객체 그래프를 탐색할 수 있다.
- 양쪽 객체 둘 다 참조를 둔다.

<br>

### 그럼 외래키는 어디서 관리하나..?
- 테이블은 외래키 하나로 두 테이블의 연관관계를 관리한다.
- 객체는 외래키를 참조로 사용한다.
- 양방향 연관관계는 양쪽 다 참조가 있다.
- 연관관계의 주인을 설정하여 기준을 잡아주어야 한다!!

<br>

### 연관관계의 주인
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.
- 2개의 단방향 중 하나를 연관관계의 주인으로 지정하여 외래키를 관리하도록 한다.
- 다음 규칙을 갖는다.
  - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정한다.
  - 연관관계의 주인만이 외래키를 관리한다. (등록, 수정)
  - 주인이 아닌쪽은 읽기만 가능하다.
  - 주인이 아니면 mappedBy 속성을 사용.
  - 주인은 mappedBy 사용 안한다.
- 누구를 주인으로 하나?
  - 외래키가 있는 곳을 주인으로 정하자.

<br>

### 양방향 매핑시 주의할 점
- 순수 객체 상태를 고려하여 항상! 양쪽에 값을 설정하자.
- 연관관계 편의 메소드를 생성하여 실수를 줄이도록 하자.
- 양방향 매핑시 무한 루프를 조심하자.

<br>

---
## 상속 관계 매핑
- RDB는 상속 관계가 없다.
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다.
- 상속관계 매핑은 객체의 상속과 구조를 DB의 슈퍼타입 서브타입 관계와 매핑한다.

<br>

### 3가지 전략이 있다.
- <b>조인 전략</b>
  - 각각 테이블로 변환한다.
  - @Inheritance(strategy=InheritanceType.JOINED)
- <b>단일 테이블 전략</b>
  - 통합 테이블로 변환한다.
  - @Inheritance(strategy=InheritanceType.SINGLE_TABLE)
- <b>구현 클래스마다 테이블 전략</b>
  - 서브타입 테이블로 변환한다.
  - @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)

주요 어노테이션은 아래와 같다.
- @DiscriminatorColumn(name="DTYPE")
  - 조상 클래스에 달아서 표시할 컬럼 명을 지정
- @DiscriminatorValue("XXX")
  - 자손 클래스에 달아서 컬럼에 입력할 값을 지정

<br>

### 전략별 장단점
<b>조인 전략</b>
- 장점
  - 테이블 정규화
  - 외래키 참조 무결성 제약조건 활용 가능
  - 저장공간 효율화
- 단점
  - 조회시 조인을 많이 사용하여 성능 저하
  - 조회 쿼리가 복잡하다
  - 데이터 저장시 INSERT Query 2번 호출한다.
    - 조상테이블, 자손테이블 각각 한 번씩

<b>단일 테이블 전략</b>
- 장점
  - 조인이 필요없으므로 일반적으로 조회 성능이 빠르다
  - 쿼리 단순하다
- 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 null 허용한다
  - 단일 테이블에 모든 것을 저장하여 테이블이 커질 수 있다.
  - 상황에 따라 조회성능이 오히려 느릴 수 있다

<b>구현 클래스마다 테이블 전략</b>
- 장점
  - 서브 타입을 명확하게 구분하여 처리할 때 효과적이다.
  - not null 제약조건 사용 가능
- 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느리다.
    - UNION SQL
  - 자식 테이블을 통합해서 쿼리하기 어렵다

<br>

### @MappedSuperclass
- 공통 매핑 정보가 필요할 때 사용한다.
- 상속관계 매핑이 아니다.
- 엔티티가 아니다. 따라서 테이블과 매핑되지 않는다.
- 단지 상속받는 자식 클래스에 매핑 정보만 제공한다.
- 직접 생성해서 사용할 일이 없으므로 추상 클래스로 사용하자.

<br>

---
## 프록시
추가 예정
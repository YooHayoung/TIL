# JPA

##  JPA 란?
- Java Persistence API
- 자바 진영의 ORM 기술 표준이다.

<br>

## 그럼 ORM 은?
- Object-relational mapping (객체 관계 매핑)
- 객체는 객체대로 설계하고 RDB는 RDB대로 설계한다.
- ORM 프레임워크가 중간에서 매핑해준다. (JPA)

<br>

## JPA는 표준 명세다.
- JPA는 인터페이스의 모음이다.
- 이를 구현한 3가지 구현체로는 Hibernate, EclipseLink, DataNucleus 있다.

<br>

## JPA는 왜 써야하나?
- SQL 중심적인 개발에서 객체 중심으로 개발할 수 있다.
- 생산성 증가
- 유지보수 Good
- 패러다임 불일치 해결
- 높은 성능
- 데이터 접근 추상화와 벤더 독립성 (?)
- 표준이다.
  
<br>

---

<br>

# JPA 구동 방식
- Persistence 에서 설정 정보 조회
- 이를 기반으로 EntityManagerFactory 생성 <br> EntityManagerFactory는 1개만 생성하여 애플리케이션이 공유한다.
- EntityManagerFactory가 EntityManager 생성. <br> EntityManager는 Factory에서 Session마다 생성하여 사용하고 버린다. 쓰레드마다 공유 X
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행된다.

<br>

---

<br>

# 영속성 컨텍스트
- JPA를 이해하는데 가장 중요한 용어다.
- 엔티티를 영구 저장하는 환경이라는 뜻
- 논리적인 개념
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.
- J2SE 환경에서는 EntityManager와 영속성 컨텍스트가 1:1 임
- J2EE, Spring Framework 같은 Container 환경에서는 EntityManager와 영속성 컨텍스트가 N:1 이다.

<br>

## Entity의 생명주기
- 비영속 <br> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 <br> 영속성 컨텍스트에 관리되는 상태
- 준영속 <br> 영속성 컨텐스트에 저장되었다가 분리된 상태
- 삭제 <br> 삭제된 상태

<br>

## 그럼 영속성 컨텍스트를 통하면 얻는게 뭔데?
- 1차 캐시
  - Entity를 영속화하거나 DB에 저장된 Entity를 불러오면 1차 캐시에 일단 저장한다. 
  - DB에 검색을 할 때, 1차 캐시에서 먼저 확인 후 존재하는 Entity는 Query를 날리지 않고 가져온다.
  - 1차 캐시에 없다면 그 때 DB Server에 Query를 날려서 가져온다.
- 동일성(identity) 보장
  - 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 DB가 아닌 Application 차원에서 제공한다.
  - 1차 캐시에서 가져온 Entity는 동일한 Entity임을 보장 하는 것이다. ( == 비교 true )
- 트랜잭션을 지원하는 쓰기 지연
  - EntityManager.persist(member) <- 영속화 시점에 DB에 SQL을 보내는 것이 아니다.
  - 1차 캐시에 저장하였다가 commit 시점에 SQL을 전송하여 DB에 저장한다.
- Dirty Checking
  - 트랜잭션 내에서 영속 상태의 Entity를 수정한다.
  - 트랜잭션 커밋 시점에 1차 캐시에서 Entity의 스냅샷과 비교한다.
  - 스냅샷과 다르면 update Query를 날린다.
- Lazy Loading

<br>

---

<br>

# Entity Mapping

<br>

## @Entity
- JPA가 관리하는 클래스에 붙인다.
- JPA를 사용하여 테이블과 매핑할 클래스는 @Entity 필수임
- JPA spec상 public or protected 기본 생성자 필요하다.
- final 클래스, enum, interface, inner 클래스 사용 불가
- 저장할 필드에 final 사용 불가

<br>

## 매핑 어노테이션 정리
- @Column <br> 컬럼 매핑
- @Temporal <br> 날짜 타입 매핑 (요즘엔 LocalDateTime을 사용해서 잘 안쓴다)
- @Enumerated
  - enum 타입 매핑
  - value 속성에 ORDINAL이 아닌 STRING을 사용하자.
  - ORDINAL 사용하면 enum 값이 변경될 시에 순서가 변경될 우려가 있다.
- @Lob <br> BLOB, CLOB 매핑
- @Transient <br> 특정 필드를 컬럼에 매핑하지 않는다.

<br>

---

# 연관관계 매핑 
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
- 테이블은 외래키로 조인을 사용하여 연관된 테이블을 찾는다.
- 객체는 참조를 사용해서 연관된 객체를 찾는다.
- 객체를 테이블에 맞추어 모델링하면 참조가 아닌 외래키 식별자를 다루어 해당 식별자로 객체를 다시 조회하게 된다.
- 이건 객체지향스럽지 않다...

<br>

## 그래서 어떻게 해결하는데?
- 객체지향 모델링을 하자.
- 테이블의 외래키를 객체의 참조와 매핑하는 것이다.
- 이를 연관관계라고 한다.
- 참조를 통해 객체 그래프 탐색 가능

<br>

## 단방향 연관관계
- 한 방향으로만 객체 그래프 탐색할 수 있는 연관관계이다.
- 한쪽 객체에 참조를 두고 다른쪽은 두지 않는다.

<br>

## 양방향 연관관계
- 양방향으로 객체 그래프를 탐색할 수 있다.
- 양쪽 객체 둘 다 참조를 둔다.

<br>

## 그럼 외래키는 어디서 관리하나..?
- 테이블은 외래키 하나로 두 테이블의 연관관계를 관리한다.
- 객체는 외래키를 참조로 사용한다.
- 양방향 연관관계는 양쪽 다 참조가 있다.
- 연관관계의 주인을 설정하여 기준을 잡아주어야 한다!!

<br>

## 연관관계의 주인
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.
- 2개의 단방향 중 하나를 연관관계의 주인으로 지정하여 외래키를 관리하도록 한다.
- 다음 규칙을 갖는다.
  - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정한다.
  - 연관관계의 주인만이 외래키를 관리한다. (등록, 수정)
  - 주인이 아닌쪽은 읽기만 가능하다.
  - 주인이 아니면 mappedBy 속성을 사용.
  - 주인은 mappedBy 사용 안한다.
- 누구를 주인으로 하나?
  - 외래키가 있는 곳을 주인으로 정하자.

<br>

## 양방향 매핑시 주의할 점
- 순수 객체 상태를 고려하여 항상! 양쪽에 값을 설정하자.
- 연관관계 편의 메소드를 생성하여 실수를 줄이도록 하자.
- 양방향 매핑시 무한 루프를 조심하자.

<br>

---
# 상속 관계 매핑
- RDB는 상속 관계가 없다.
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다.
- 상속관계 매핑은 객체의 상속과 구조를 DB의 슈퍼타입 서브타입 관계와 매핑한다.

<br>

## 3가지 전략이 있다.
- <b>조인 전략</b>
  - 각각 테이블로 변환한다.
  - @Inheritance(strategy=InheritanceType.JOINED)
- <b>단일 테이블 전략</b>
  - 통합 테이블로 변환한다.
  - @Inheritance(strategy=InheritanceType.SINGLE_TABLE)
- <b>구현 클래스마다 테이블 전략</b>
  - 서브타입 테이블로 변환한다.
  - @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)

주요 어노테이션은 아래와 같다.
- @DiscriminatorColumn(name="DTYPE")
  - 조상 클래스에 달아서 표시할 컬럼 명을 지정
- @DiscriminatorValue("XXX")
  - 자손 클래스에 달아서 컬럼에 입력할 값을 지정

<br>

## 전략별 장단점
<b>조인 전략</b>
- 장점
  - 테이블 정규화
  - 외래키 참조 무결성 제약조건 활용 가능
  - 저장공간 효율화
- 단점
  - 조회시 조인을 많이 사용하여 성능 저하
  - 조회 쿼리가 복잡하다
  - 데이터 저장시 INSERT Query 2번 호출한다.
    - 조상테이블, 자손테이블 각각 한 번씩

<b>단일 테이블 전략</b>
- 장점
  - 조인이 필요없으므로 일반적으로 조회 성능이 빠르다
  - 쿼리 단순하다
- 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 null 허용한다
  - 단일 테이블에 모든 것을 저장하여 테이블이 커질 수 있다.
  - 상황에 따라 조회성능이 오히려 느릴 수 있다

<b>구현 클래스마다 테이블 전략</b>
- 장점
  - 서브 타입을 명확하게 구분하여 처리할 때 효과적이다.
  - not null 제약조건 사용 가능
- 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느리다.
    - UNION SQL
  - 자식 테이블을 통합해서 쿼리하기 어렵다

<br>

## @MappedSuperclass
- 공통 매핑 정보가 필요할 때 사용한다.
- 상속관계 매핑이 아니다.
- 엔티티가 아니다. 따라서 테이블과 매핑되지 않는다.
- 단지 상속받는 자식 클래스에 매핑 정보만 제공한다.
- 직접 생성해서 사용할 일이 없으므로 추상 클래스로 사용하자.

<br>

---
# 프록시

## Member 조회시 Team도 함게 조회해야 하나?
```java
public class Member () {
  String username;
  Team team;
}

public class Team () {
  String name;
}
```

- 회원 데이터만 필요하면 team 조회는 필요없다.
- 그런데 객체로만 보자면 team 참조에 의해 team도 조회하는 것으로 보인다.

<br>

## Member만 조회하려면?
- 프록시를 사용한다.

<br>

## 프록시란?
- DB 조회를 미루는 가짜 엔티티 객체
- 실제 클래스를 상속받아서 만들어진다.
- 실제 클래스와 겉모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지않고 사용하면 된다. <- 이론상

## 프록시 객체의 특징
- 프록시 객체는 실제 객체의 참조를 보관한다
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드를 호출한다
- 프록시 객체는 처음 사용할 때 한 번만 초기화한다
- 프록시 객체가 초기화된다고 실제 엔티티로 바뀌는 것이 아니다.
- 타입 체크시 instance of를 사용한다. 원본 엔티티를 상속받은 것이기 때문이다.

## 그래서 프록시는 어떻게 쓰지?
- @ManyToOne, @OneToMany 등 다중성 설정할 때 fetch 속성을 지정해준다.
- 지연로딩, 즉시로딩 있다.
- 지연로딩
  - fetch=FetchType.LAZY
  - 해당 속성이 지정된 참조 객체는 프록시로 조회되어 프록시가 사용될 때 까지 실제 엔티티 조회를 미룬다.
- 즉시로딩
  - fetch=FetchType.EAGER
  - 객체 조회시 프록시로 가져오는 것이 아니라 실제 엔티티를 같이 가져온다.

## 가능하면 지연로딩만 쓰자!
- 즉시로딩을 적용하면 예상하지 못한 SQL이 발생한다.
- 즉시로딩은 JPQL에서 N + 1 문제를 발생시킨다.
- ToOne은 기본이 즉시로딩이다. LAZY로 설정해주자.
- ToMany는 기본이 지연로딩이다.

<br>

---

# 영속성 전이 CASCADE

## 특정 엔티티를 영속상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들고 싶다면?
- 영속성전이 CASCADE 속성을 이용하자.
  - cascade=CascadeType.PERSIST : 함께 영속화
  - cascade=CascadeType.REMOVE : 함께 삭제
  - cascade=CascadeType.ALL : 전체 적용
  - MERGE, REFRESH, DETACH 도 있다.
- 영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없다
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.

<br>

---

# 고아 객체

## 고아 객체란?
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 말한다.
- 부모 엔티티의 자식 엔티티 컬렉션에서 자식 엔티티를 제거하면?
- ex) `parent.getChildList().remove(0);` 인덱스 0의 자식 엔티티 제거
  - 자식 엔티티는 부모 엔티티와의 연관관계가 끊어졌다.

## 고아 객체를 자동으로 삭제 해주는 기능
- `orphanRemoval = true` 를 이용한다.
- 연관관계가 끊어지면 자동으로 엔티티 삭제한다.
- CascadeType.REMOVE 처럼 동작

## 조심하자.
- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.
- 다른 곳에서도 이를 참조한다면 예기치 못한 문제가 발생한다!!
- 꼭 참조하는 곳이 하나일 때 사용해야한다!
- OneTo- 만 사용 가능하다.


<br>

## 영속성 전이 + 고아 객체
- `CascadeType.All` + `orpahnRemovel=ture`
- 해당 옵션을 모두 활성화 하면 부모 엔티티를 통해 자식의 생명주기를 관리할 수 있다.
- 스스로 생명주기를 관리하는 엔티티는 `EntityManager.persist()`, `EntityManager.remove()` 를 통해 영속화, 제거되고, 자식 엔티티는 부모의 생명주기에 맞춰 영속화, 제거된다.

<br>

---
# 값 타입

## JPA의 데이터 타입
- JPA의 데이터 타입은 크게 두가지로 분류된다.
- 엔티티 타입
  - @Entity
  - 데이터가 변해도 식별자로 지속 추적 가능
- 값 타입
  - int, Integer, String 등 단순히 값으로 사용하는 자바 기본타입 or 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가

## 값 타입의 분류
- 값 타입은 다시 세갈래로 나뉜다.
- 기본값 타입
  - 자바 기본 타입 `int`, `double` 등
  - 래퍼 클래스 `Integer`, `Long` 등
  - String
- 임베디드 타입
  - embedded type, 복합 값 타입
- 컬렉션 타입
  - list 등

## 임베디드 타입이 뭔데?
- 직접 정의한 새로운 값 타입
- 기본 값 타입(int, String 등)을 모아서 만든다.
- 복합 값 타입이라고도 한다.
- city, street, zipcode 라는 속성을 같은 Address 라는 클래스를 만들어 임베디드 타입으로 지정한다.
- Entity 클래스에서 Address 객체를 값 타입으로 사용할 수 있다.
- 참조를 저장하는 것이 아니라 해당 임베디드 타입 객체의 속성을 저장한다.
- `@Embeddeable` 값 타입 정의시, `@Embedded` 값 타입 사용시

## 임베디드 타입이 뭐가 좋은가?
- 재사용성
- 높은 응집도
- 해당 값 타입만 사용하는 의미있는 메소드 생성 가능
- 값 타입을 소유한 엔티티에 생명주기를 의존한다. 이는 임베디드 뿐만 아니라 모든 값 타입에 해당.

## 그러나 조심하자.
- 임베디드 타입은 값 타입 이지만 객체이다.
- 이를 여러 엔티티에서 공유하면 위험하다!
- 공유해서 다른 곳에서 내용을 변경하게 되면 side effect 발생.

## 그럼 어떻게 할까?
- 객체 타입을 수정할 수 없게 만들어 부작용을 원천 차단하자.
- 값 타입은 생성 시점 이후 절대 값을 변경할 수 없는 불변 객체로 설계해야 한다.
- 임베디드 타입 같은 값 타입의 객체는 공유하지 말고 값을 복사해서 사용하자.

## 정리
- 엔티티 타입은
  - 식별자 존재
  - 생명주기 관리
  - 공유 가능
- 값 타입은
  - 식별자가 없다
  - 생명주기를 엔티티에 의존한다
  - 공유하지 않아야 안전하다. 복사해서 사용하자
  - 불변 객체로 만들어야 안전하다.

<b>식별자가 필요하고, 지속해서 값을 추적, 변경해야 하면, 그것은 값 타입이 아니라 엔티티 타입이다.</b>


<br><br><br><br>
---
해당 내용은 김영한님의 강의를 듣고 정리한 내용입니다.
# 예외 처리
웹 애플리케이션에서 예외가 발생하면 try ~ catch로 예외를 잡아서 처리하면 문제가 발생하지 않지만 그렇지 않고 예외를 잡지 못하게 되면 WAS 까지 예외가 전달된다.
`throw new Exception();` or `response.sendError()`

## 오류페이지 동작 원리
서블릿은 Exception이 발생하여 서블릿 밖으로 전달되거나 response.sendError()가 호출 되면 이에 설정된 오류 페이지를 찾는다.

	- 컨트롤러 -> 인터셉터 -> 서블릿 -> 필터 -> WAS(예외 또는 sendError 호출 확인) -> WAS에서 오류 페이지 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러 -> 오류페이지 Render
위와 같은 과정을 거치게 된다.

이 때, 오류 정보를 request의 attribute에 추가하여 넘겨주어 필요하면 오류 페이지에서 전달된 오류 정보를 사용할 수 있다. 오류 정보는 `RequestDispatcher` 상수로 정의되어 있다. 이를 아래와 같이 `request.getAttribute()`로 꺼내서 쓰면 된다.
```java
request.getAttribute(RequestDispatcher.ERROR_MESSAGE);
```


## 오류 페이지 등록 및 구현
스프링부트에서 제공하는 기본 예외 페이지를 끄고 예외를 발생시키면 톰캣에서 기본 제공하는 예외 처리 페이지를 볼 수 있다. 이를 서비스에 적합한 오류 페이지를 보여주기 위해서는 서블릿 오류 페이지를 등록해야 한다.
`WebServerCustomizer`
```java
	@Component 
  public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
      @Override
      public void customize(ConfigurableWebServerFactory factory) {
          ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");

          ErrorPage errorPage500 = new
  ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");

          ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");

          factory.addErrorPages(errorPage404, errorPage500, errorPageEx);
      }
}
```

서블릿 오류 페이지를 등록하고 나면 이를 처리할 컨트롤러와 오류 페이지를 만든다.
`ErrorPageController`
```java
@Controller
public class ErrorPageController {
	@RequestMapping("/error-page/404")
	public String errorPage404(HttpServletRequest request, HttpServletResponse response) {
		return "error-page/404";
	}

	@RequestMapping("/error-page/500")
	public String errorPage500(HttpServletRequest request, HttpServletResponse response) {
		return "error-page/500";
	}

	// ...
}
```

컨트롤러와 오류 페이지까지 만들고 나면 설정한 예외와 에러가 발생하면 오류 페이지로 이동하게 된다. 

## 필터 및 인터셉터 처리
예외나 오류가 발생하면, 클라이언트 요청 -> 필터 및 인터셉터 거침 -> 컨트롤러(예외 발생) -> WAS 까지 예외 전달 -> 이후 WAS 에서 오류 페이지를 위한 요청 -> 다시 필터 및 인터셉터 거쳐서 에러 페이지 컨트롤러에서 view 렌더링 의 과정을 거치는데 WAS -> 예외컨트롤러 까지의 과정에서 필터와 인터셉터가 정상 요청 이후, 한번 더 호출되는 비효율적인 과정이 발생한다.
필터와 인터셉터를 중복 호출되지 않도록 하기 위한 방법이 필요하다.

### 필터
필터는 이를 위하여 `dispatcherTypes`라는 옵션을 제공하는데 이는 다음과 같은 값을 가진다.
```java
public enum DispatcherType {
      FORWARD, // 서블릿 -> 다른 서블릿 호출할 때
      INCLUDE, // 서블릿 -> 다른 서블릿의 결과를 포함할 때
      REQUEST, // 클라이언트 요청
      ASYNC, // 서블릿 비동기 호출
      ERROR // 오류 요청
} 
```

이를 이용하여 특정 `dispatcherTypes`에만 필터를 적용하려면 `WebConfig`에 다음을 포함하면 된다.
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
	
	@Bean
	public FilterRegistrationBean logFilter() {
		// ... 기존 설정

		// 클라이언트 요청에만 필터를 호출한다.
		filterRegistrationBean
			.setDispatcherTypes(DispatcherType.REQUEST); // 기본값

		// .setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR) 이처럼 여러 타입을 넣을 수도 있다.

		return filterRegistrationBean;
	}
}
```


### 인터셉터
인터셉터는 스프링이 제공하는 기능이기 때문에 `DispatcherType`과 무관하게 항상 호출된다. 하지만 인터셉터는 요청 경로에 따라서 추가하거나 제외하기 쉽게 되어있다. `excludePathPatterns`를 사용하여 인터셉터를 적용할 페이지를 빼주면 된다.

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
	
	@Override
	public void addInterceptiors(InterceptorRegistry registry) {
		registry.addInterceptor(new LogInterceptor())
				.order(1)
				.addPathPatterns("/**")
				.excludePathPatterns("/css/**", "/*.ico", 
							"/error", "오류 페이지 경로");
	}
}
```



## 스프링 부트의 오류 페이지
스프링 부트는 이러한 과정을 모두 기본으로 제공한다. 스프링 부트는 `ErrorPage`를 자동으로 등록하는데 `/error`라는 경로로 기본 오류 페이지를 설정한다. 모든 오류는 `/error`를 호출한다. 또한 이를 처리할 컨트롤러를 제공한다. `BasicErrorController`라는 스프링 컨트롤러를 자동으로 등록한다. 이는 `ErrorPage`에서 등록한 `/error`를 매핑해서 처리한다.

이를 사용하려면 오류 페이지 화면만 `BasicErrorController`가 제공하는 규칙과 우선순위에 따라서 등록하면 된다.  규칙과 우선순위는 다음과 같다.
1. 뷰 템플릿
	- `resources/templates/error/500.html`
	- `resources/templates/error/5xx.html`
2. 정적 리소스
	- `resources/static/error/400.html`
	- `resources/static/error/4xx.html`
3. 적용 대상이 없을 때 뷰 이름
	- `resources/templates/error.html`

또한 `BasicErrorController`는 아래 정보들을 model에 담아서 뷰에 전달한다.
	- `timestamp` : Fri Feb 05 00:00:00 KST 2021
	- `status` : 400
	- `error` : Bad Request
	- `exception` : org.springframework.validation.BindException * trace: 예외 trace 
	- `message` : Validation failed for object=‘data’. Error count: 1 * errors: Errors(BindingResult)
	- `path` : 클라이언트 요청 경로 

오류 관련 정보들을 외부에 노출하는 것은 보안상 문제가 될 수도 있기 때문에 주의해야한다. `application.properties`에서 다음 오류 정보를 model에 포함할지 여부를 선택할 수 있다.
	- server.error.include-exception=true || false
	- server.error.include-message=never || always || on_param 
	- server.error.include-stacktrace=never || always || on_param
	- server.error.include-binding-errors=never || always || on_param
		- never (사용 X) || always (항상 사용) || on_param (URL 파라미터가 있으면 사용)

never로 설정하여 오류 정보를 포함시키지 않도록 하여 뷰에는 간단한 오류 메시지를 보여주고 오류는 서버에 로그로 남겨서 확인하도록 하는 것이 가장 좋은 방법이라고 생각한다.


### 스프링 부트가 제공하는 에러 처리 컨트롤러 기능 확장 방법
에러 공통 처리 컨트롤러의 기능을 변경하고 싶으면 `ErrorController` 인터페이스를 상속 받아 구현 하거나 `BasicErrorController`를 상속받아서 기능을 추가하면 된다.


- Whitelabel Error Page on || off : `server.error.whitelabel.enabled=true || false`
- 오류 페이지 경로 설정 : `server.error.path=/error`
	- 스프링이 자동 등록하는 서블릿 글로벌 오류 페이지 경로와 `BasicErrorController` 오류 컨트롤러 경로에 함께 사용된다.


- - - -
해당 내용은 김영한님의 강의를 듣고 정리한 내용입니다.